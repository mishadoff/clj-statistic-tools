#include <iostream>
#include <algorithm>
#include <cassert>
using namespace std;
typedef long long lli;

const int MAXK = 100005;

namespace RMQ {
  const int MAX_N = MAXK*3;
  const lli INF = 1LL<<60;

  int n;
  lli dat[4*MAX_N-1];
  void init(int _n = MAX_N) {
    n = 1;
    while(n < _n) n *= 2;
    for(int i = 0; i < 2*n-1; ++i) dat[i] = INF; // dat[i] = 0; // #1
  }

  void update(int k, lli a) {
    k += n-1;
    // int d = a - dat[k]; // #1
    dat[k] = a;
    while(k > 0) {
      k = (k - 1) / 2;
      dat[k] = min(dat[k*2+1], dat[k*2+2]); // dat[k] += d; // #1
    }
  }

  // [a, b)の最小値を求める
  // #1: [a, b)の和を求める
  // O(logN)
  // query(a, b);
  // query(a, b, 0, 0, RMQ::n);
  lli query(int a, int b, int k = 0, int l = 0, int r = RMQ::n) {
    if(r <= a || b <= l) return INF; // return 0; // #1
    if(a <= l && r <= b) return dat[k];
    else {
      lli v1 = query(a, b, k*2+1, l, (l + r) / 2);
      lli v2 = query(a, b, k*2+2, (l + r) / 2, r);
      return min(v1, v2); // return v1 + v2; // #1
    }
  }
}




int main() {
  int Tc;
  cin >> Tc;
  for(int tc = 0; tc < Tc; ++tc) {
    lli n, k;
    lli a, b, c, r;
    lli m[MAXK*2+1];
    cin >> n >> k;
    cin >> a >> b >> c >> r;

    m[0] = a;
    for(int i = 1; i < k; ++i) {
      m[i] = (b * m[i-1] + c) % r;
    }

    lli num[MAXK];
    fill(num, num+MAXK, 0LL);
    RMQ::init();
    for(int j = 0; j <= k; ++j) {
      RMQ::update(j, j);
    }
    for(int i = 0; i < k; ++i) {
      if(0 <= m[i] && m[i] <= k) {
        num[m[i]] += 1;
        RMQ::update(m[i], RMQ::INF);
      }
    }

    for(int i = k; i < k*2+1; ++i) {
      m[i] = RMQ::query(0, k+1);
      if(m[i] == RMQ::INF) assert(false);
      num[m[i]] += 1;
      RMQ::update(m[i], RMQ::INF);
      if(0 <= m[i-k] && m[i-k] <= k) {
        if(--num[m[i-k]] == 0) {
          RMQ::update(m[i-k], m[i-k]);
        }
      }
    }

    lli res = m[k + (n-k-1) % (k+1)];
    cout << "Case #" << tc+1 << ": " << res << endl;
  }
  return 0;
}
