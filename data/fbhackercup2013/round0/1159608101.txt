#include <vector>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <string>
#include <cstring>
#include <fstream>
#include <cassert>
using namespace std;

#define all(o) (o).begin(), (o).end()
#define allr(o) (o).rbegin(), (o).rend()
const int INF = 2147483647;
typedef long long ll;
typedef pair<int, int> ii;
typedef vector<int> vi;
typedef vector<ii> vii;
typedef vector<vi> vvi;
typedef vector<vii> vvii;
template <class T> int size(T x) { return x.size(); }

// assert or gtfo

class fenwick_tree {
private:
	int* arr;
	int cnt;

	inline int lsone(int n) {
		return n & -n;
	}

public:
	fenwick_tree(int n) {
		arr = new int[(cnt = n) + 1];
		clear();
	}

	~fenwick_tree() {
		if (arr) {
			delete[] arr;
			arr = NULL;
		}
	}

	fenwick_tree(const fenwick_tree& other) {
		arr = new int[(cnt = other.cnt) + 1];
		for (int i = 0; i <= cnt; i++)
			arr[i] = other.arr[i];
	}

	void clear() {
		memset(arr, 0, (cnt + 1) << 2);
	}

	void adjust(int i, int v) {
		assert(arr != NULL);
		assert(i >= 0 && i < cnt);

		i++;
		while (i <= cnt) {
			arr[i] += v;
			i += lsone(i);
		}
	}

	int rsq(int i) {
		assert(arr != NULL);

		if (i < 0)
			return 0;
		if (i >= cnt)
			return rsq(cnt - 1);

		i++;
		int sum = 0;
		while (i) {
			sum += arr[i];
			i -= lsone(i);
		}

		return sum;
	}

	inline int rsq(int i, int j) {
		return rsq(j) - rsq(i - 1);
	}

	inline int get(int i) {
		return rsq(i) - rsq(i - 1);
	}

	int find_first_zero() {
		int lo = 0, hi = cnt - 1;
		while (lo < hi) {
			int mid = hi - (hi - lo) / 2;
			//printf("%d %d %d %d\n", lo, hi, mid, rsq(mid));
			if (rsq(mid - 1) < mid) hi = mid - 1;
			else lo = mid;
		}

		//printf("%d %d\n", lo, hi);

		return lo;
	}
};

int main()
{
	//fenwick_tree bla(10);
	//printf("%d\n", bla.find_first_zero());
	//bla.adjust(0, 1);
	//printf("%d\n", bla.find_first_zero());
	//bla.adjust(2, 1);
	//printf("%d\n", bla.find_first_zero());
	//bla.adjust(1, 1);
	//printf("%d\n", bla.find_first_zero());
	//return 0;

	int ts;
	scanf("%d\n", &ts);

	for (int t = 0; t < ts; t++)
	{
		//ftcnt.clear();
		//ftcontains.clear();

		//fenwick_tree ftcnt(1000000001);
		fenwick_tree ftcontains(1000000001);
		int* cnt = new int[1000000001];
		memset(cnt, 0, 1000000001 << 2);

		int n, k, a, b, c, r;
		scanf("%d %d\n%d %d %d %d\n", &n, &k, &a, &b, &c, &r);

		int* arr = new int[k+1];
		arr[0] = a;
		for (int i = 1; i < k; i++)
			arr[i] = static_cast<int>((b * static_cast<long long>(arr[i - 1]) + c) % r);
		
		for (int i = 0; i < k; i++)
		{
			if (++cnt[arr[i]] == 1)
				ftcontains.adjust(arr[i], 1);
			//printf("%d ", arr[i]);
		}

		//printf("\n");

		for (int i = k; i < 2*k+1; i++)
		{
			int nxt = ftcontains.find_first_zero();
			//printf("%d: %d\n", i % (k+1), nxt);

			if (--cnt[arr[(i + 1) % (k+1)]] == 0)
				ftcontains.adjust(arr[(i + 1) % (k+1)], -1);

			arr[i % (k+1)] = nxt;
			if (++cnt[nxt] == 1)
				ftcontains.adjust(nxt, 1);
			//printf("%d\n", i);
			//printf("%d ", nxt);
		}

		//printf("\n");

		printf("Case #%d: %d\n", t+1, arr[(n-1) % (k+1)]);

		delete[] arr;
		delete[] cnt;
	}

	return 0;
}