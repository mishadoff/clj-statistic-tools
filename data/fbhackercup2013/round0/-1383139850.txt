/**
Calvin's Code
*/
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <algorithm>
#include <cstring>
#include <utility>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstdio>
using namespace std ;
const int maxint = -1u>>2 ;
const double eps = 1e-6 ;

int m[1000000];

int main() {
	freopen("find_the_mintxt.txt", "r", stdin);
	freopen("find_the_minout.txt", "w", stdout);
	int tc, TC, n, k, a, b, c, r, i, j;
	scanf(" %d", &TC);
	for (tc = 1; tc <= TC; ++tc) {
        scanf(" %d %d %d %d %d %d", &n, &k, &a, &b, &c, &r);

        m[0] = a;
        for (i = 1; i < k; ++i) {
            m[i] = (int)(((long long) b *m[i-1] + c)%(long long)r);
        }

        multiset<int> s1;
        set<int> s2, s3;
        //god like...

        for (i = 0; i < k; ++i)
            s1.insert(m[i]);
        int cur = 0;

        for (i = 0; i <= k; ++i)
            if (s1.count(i) != 0)
                s2.insert(i);
        for (i = 0; i <= k; ++i)
            if (s2.count(i) == 0)
                s3.insert(i);

        multiset<int>::iterator itr1;
        set<int>::iterator itr2;
        set<int>::iterator itr3;
        for (i = k; i <= min(200005, n); ++i) {
            m[i] = *s3.begin();
            s3.erase(s3.begin());
            s1.insert(m[i]);

            itr1 = s1.find(m[cur]);
            s1.erase(itr1);

            if (s1.count(m[cur]) == 0) {
                if (0 <= m[cur] && m[cur] <= k) {
                    s2.erase(m[cur]);
                    s3.insert(m[cur]);
                }
            }
            cur++;
        }
        printf("Case #%d: ", tc);
        int ans = 0;
        if (n <= 200005)
            ans = m[n-1];
        else
            ans = m[(n-k-1) % (k+1) + k];
        printf("%d\n", ans);
	}
	return 0;
}
