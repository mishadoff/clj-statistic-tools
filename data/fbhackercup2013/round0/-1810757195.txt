/* by Ashar Fuadi [fushar] */

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <cmath>

#include <set>
#include <map>
#include <list>
#include <queue>
#include <vector>
#include <string>
#include <utility>
#include <iostream>
#include <algorithm>

using namespace std;

#define REP(i,n) for (int i = 0; i < (int)n; i++)
#define FOR(i,a,b) for (int i = (int)a; i <= (int)b; i++)
#define RESET(c,v) memset(c, v, sizeof(c))
#define FOREACH(i,c) for (typeof((c).end()) i = (c).begin(); i != (c).end(); ++i)

typedef long long ll;

#define pb push_back
#define mp make_pair

int T, N, K;
ll a, b, c, r;
int data[1000005], last[1000005];
pair<int, int> cand[1000005];
priority_queue<int> pq;
int main()
{
	scanf("%d", &T);
	REP(tc, T)
	{
		scanf("%d%d", &N, &K);
		scanf("%lld%lld%lld%lld", &a, &b, &c, &r);
		
		data[0] = a;
		for (int i = 1; i < K; i++)
			data[i] = (b * data[i-1] + c) % r;
		
		REP(i, K+K+1)
			last[i] = K;
		
		REP(i, K)
			if (data[i] < K+K+1)
				last[data[i]] = i+K+1;
		
		REP(i, K+K+1)
			cand[i] = mp(last[i], i);
		sort(cand, cand+K+K+1);
		
		while (!pq.empty())
			pq.pop();
			
		int pos = 0;
			
		REP(i, K+1)
		{
			while (pos < K+K+1 && cand[pos].first <= i+K)
			{
				pq.push(-cand[pos].second);
				pos++;
			}
			data[i+K] = -pq.top();
			pq.pop();
		}
		
		//REP(i, K+K+1)
			//printf("%d: %d   %d\n", i, data[i], last[i]);
		
		if (N <= K)
			printf("Case #%d: %d\n", tc+1, data[N-1]);
		else
			printf("Case #%d: %d\n", tc+1, data[N % (K+1) + K]);
	}
}
